function srforest = trainVSRF( opts, imlistHigh, imlistLow)
% srForestTrain3D Training of a super-resolution random forest with 3-D
% patches
% 
% This function trains a random regression forest for the task of single
% image super-resolution for the application to MRI based on [1].
% The function was adapted from [1] for the use of MRI by extracting 3-D 
% patches from the MR volumes. 
% For training low-resolution (LR) and high-resolution (HR) MR volumes are 
% required. The input for the method can either be datapaths to both LR and 
% HR volumes or only to HR volumes. Then, the LR volumes are generated by
% downsampling. The code works with .mat files for the MR volumes.
% Furthermore, super-resolution options, such as the scaling factor have to
% be defined and passed to this method (see main_RandomForst_MRI.m).
%
% USAGE
%  opts     = srForestTrain( )
%  srforest = srForestTrain( opts, imlistHigh, imlistLow )
%
% INPUTS
%  opts                   - additional params (struct)
%   .sf                   - [2] upscaling factor
%   .patchSize            - [3 3 3] patch size in high-dim images
%   .patchStride          - [2 2 2] stride of patch extraction
%   .patchBorder          - [0 0 0] border of patch extraction
%   .patchfeats           - [..] feature params (see computeFeats.m)
%   .interpolMethod       - ['tricubic'] interpolation kernel for upscaling
%   .downsamplingMethod   - ['tricubic'] interpolation kernel for 
%                           downsampling
%   .pRegrForest          - [..] forest params (see forestRegrTrain.m)
%   .verbose              - [1] verbosity level
% imlistHigh              - path to to HR train MR volumes (.mat)
% imlistLow               - path to to LR train MR volumes (.mat) 
%                           If imlistLow is set empty, the HR images are 
%                           downscaled and the result is used as LR.
%
% OUTPUTS
%  srforest               - super-resolution forest
%   .model                - the trained random regression forest model 
%   .Vpca                 - PCA projection matrix for feature computation
%   .sropts               - the options struct
%
% See also: srForestApply, forestRegrTrain
% 
% @author Aline Sindel
%
% REFERENCES:
% [1] S. Schulter, C. Leistner, H. Bischof. Fast and Accurate Image
%     Upscaling with Super-Resolution Forests. CVPR 2015.
% [2] R. Timofte, V. De Smet, L. van Gool. A+: Adjusted Anchored
%     Neighborhood Regression for Fast Super-Resolution. ACCV 2014.
% [3] Roman Zeyde, Michael Elad, and Matan Protter. On single image 
%     scale-up using sparse-representations. Curves and Surfaces: 7th 
%     International Conference, Avignon, France, June 24 - 30, 2010.
%
% The code is adapted from [1] and the Piotr's Image&Video Toolbox 
% (Copyright Piotr Dollar). Feature computation is based on [2,3].

if nargin == 0, opts = struct; end
if ~isfield(opts, 'sf'),opts.sf = 2; end
if ~isfield(opts, 'patchSize'),opts.patchSize = [3 3 3]; end
if ~isfield(opts, 'patchStride'),opts.patchStride = [2 2 2]; end
if ~isfield(opts, 'patchBorder'),opts.patchBorder = [0 0 0]; end
if ~isfield(opts, 'patchfeats'),opts.patchfeats = []; end
if ~isfield(opts, 'interpolMethod'),opts.interpolMethod = 'tricubic'; end
if ~isfield(opts, 'downsamplingMethod'),opts.downsamplingMethod = 'tricubic'; end
if ~isfield(opts, 'pRegrForest'),opts.pRegrForest = forestRegrTrain(); end
if ~isfield(opts, 'verbose'),opts.verbose = 1; end
if nargin == 0, srforest=opts; return; end

% check some parameter settings
if opts.sf<2, error('sf should be >= 2'); end
if any(opts.patchSize<3), error('patchSize should be >= 3'); end
if any(opts.patchStride>opts.patchSize)
    error('Stride is too large for patch size'); 
end

if ~isempty(imlistHigh) && ~isempty(imlistLow)
    if length(imlistHigh)~=length(imlistLow), error('#low-res ~= #high-res images'); end
end
nImages = length(imlistHigh);
patchesSrc = cell(1,length(imlistHigh)); patchesTar=patchesSrc;

for i=1:nImages
    if opts.verbose, fprintf('Extract patches from image %d/%d\n',i,length(imlistHigh)); end
    
    % read low- and high-res images  
    [imgH, voxelspacing] = loadImage(imlistHigh{i});
    imgL = [];
    if ~isempty(imlistLow)
        imgL = loadImage(imlistLow{i});
    end   
    % process images and crop patches
    [patchesSrc{i},patchesTar{i}] = extractPatchesFromImg(imgL,imgH,opts,voxelspacing);
end
clear imgL imgH;
patchesSrc = cat(2,patchesSrc{:}); 
patchesTar = cat(2,patchesTar{:}); 
if opts.verbose, fprintf('Extracted a total of %d patches from %d images\n',...
        size(patchesSrc,2),length(imlistHigh)); end
%use all samples or bagging
opts.pRegrForest.N1 = size(patchesSrc,2); %use all samples

[srforest, patchesSrc] = computePCAPatches(patchesSrc, opts);

% train the regression forest
if opts.verbose, fprintf('Training regression forest\n'); end
srforest.model = forestRegrTrain(patchesSrc,[],...
    patchesTar,opts.pRegrForest);

srforest.sropts = opts;
end

function [srcPatches,tarPatches] = extractPatchesFromImg(imgSrc,imgTar,opts,voxelspacing)
% process images and crop patches
imgTar = im2single(imgTar);
imgTar = imageModcrop(imgTar, opts.sf, opts.scaleDim == 3);

if isempty(imgSrc)
    %generate low resolution image by downsampling
    imgSrc = imageDownsampling(imgTar, 1/opts.sf, opts.downsamplingMethod);
else
    imgSrc = im2single(imgSrc);
end

% compute midres image (this is also what happens during inference!)
imgSrc = imageUpsampling(imgSrc, opts.sf, opts.interpolMethod);

% compute the target image (i.e., the patches we want to regress!)
imgTar = imgTar - imgSrc;

% extract corresponding patches and compute features
patchfeats = opts.patchfeats;
filters = patchfeats.filters;
if numel(filters)>4
    %compute z-weight for 3D filtering
    zWeight = voxelspacing(1)/voxelspacing(3); %assumption: voxelspacing(1)==voxelspacing(2)
    for i=3:3:numel(filters)
        filters{i} = filters{i}*zWeight;
    end
    patchfeats.filters = filters;
end
srcPatches = extractPatches3D(imgSrc,opts.patchSize,...
    opts.patchStride,opts.patchBorder,patchfeats);
tarPatches = extractPatches3D(imgTar,opts.patchSize,...
    opts.patchStride,opts.patchBorder); % no features
end

function [srforest, patchesSrc] = computePCAPatches(patchesSrc, opts)
% Reduce dimensionality of low-res patches (PCA)
% Code from Zeyde et al. [3]
if opts.verbose, fprintf('Applying PCA dim-reduction\n'); end
C = double(patchesSrc*patchesSrc');
[V,D] = eig(C); D = diag(D); D = cumsum(D) / sum(D);
k = find(D >= 1e-3,1); % ignore 0.1% energy
srforest.Vpca = V(:,k:end); % choose the largest eigenvectors' projection
clear C D V;
fprintf('\t %d to %d dimensions\n',size(srforest.Vpca,1),size(srforest.Vpca,2));
%apply PCA to patches
patchesSrc = srforest.Vpca' * patchesSrc;
end